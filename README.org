#+TITLE:   Hodur Engine
#+AUTHOR:  Tiago Luchini
#+EMAIL:   info@tiagoluchini.eu
#+OPTIONS: toc:t

Hodur is a domain modeling approach and collection of libraries to
Clojure.

By using Hodur you can define your domain model as data, parse and
validate it, and then either consume your model via an API or use one
of the many plugins to help you achieve mechanical results faster and
in a purely functional manner.

* Motivation

  For a deeper insight into the motivations behind Hodur, check the [[./docs/MOTIVATION.org][motivation doc]].

* Getting Started

  Hodur has a highly modular architecture. Hodur Engine (this project)
  is always required as it provides the meta-database functions and
  APIs consumed by plugins.

  Add ~hodur-engine~ as a dependency in your ~deps.edn~ file:

#+BEGIN_SRC clojure
  {:deps {:hodur-engine {:mvn/version "0.1.0"}}}
#+END_SRC

  Either ~require~ Hodur as part of your ~ns~ definition or directly:

#+BEGIN_SRC clojure
  (require '[hodur-engine.core :as hodur])
#+END_SRC

  In order to initialize an ~atom~ representing the meta-database of
  your model call function ~hodur/init-schema~:

#+BEGIN_SRC clojure
  (def meta-db (hodur/init-schema
                '[Person
                  [^String first-name
                   ^String last-name]]))
#+END_SRC

  In the above example, we are defining a ~Person~ entity with a
  ~first-name~ and a ~last-name~ both tagged as the scalar type
  ~String~.

  Alternatively, Hodur can be initialized by raw EDN paths or from
  your classpath using a ~File~ (i.e. ~clojure.java.io/resource~):

#+BEGIN_SRC clojure
  (def meta-db (-> "schemas/person.edn"
                  io/resource
                  hodur/init-path))
#+END_SRC

  Hodur's usefulness can be seen when used in conjunction with several
  plugins that take care of the mechanical aspects of your
  application. For the sake of getting started, we are also adding
  ~hodur-datomic-schema~, a plugin that creates Datomic Schemas out of
  your model to the ~deps.edn~ file:

#+BEGIN_SRC clojure
  {:deps {:hodur-engine         {:mvn/version "0.1.0"}
          :hodur-datomic-schema {:mvn/version "0.1.0"}}}
#+END_SRC

  You should ~require~ it any way you see fit:

#+BEGIN_SRC clojure
  (require '[hodur-datomic-schema.core :as hodur-datomic])
#+END_SRC

  Let's expand our ~Person~ model above by "tagging" the ~Person~
  entity for Datomic. You can read more about the concept of tagging
  for plugins in the sessions below but, in short, this is the way we,
  model designers, use to specify which entities we want to be exposed
  to which plugins.

#+BEGIN_SRC clojure
  (def meta-db (hodur/init-schema
                '[^{:datomic/tag-recursive true}
                  Person
                  [^String first-name
                   ^String last-name]]))
#+END_SRC

  The ~hodur-datomic-schema~ plugin exposes a function called ~schema~
  that generates your model as a Datomic schema payload:

#+BEGIN_SRC clojure
  (def datomic-schema (hodur-datomic/schema meta-db))
#+END_SRC

  When you inspect ~datomic-schema~, this is what you have:

#+BEGIN_SRC clojure
  [#:db{:ident :person/first-name,
        :valueType :db.type/string,
        :cardinality :db.cardinality/one}
   #:db{:ident :person/last-name,
        :valueType :db.type/string,
        :cardinality :db.cardinality/one}]
#+END_SRC

  Assuming the Datomic client API is bound to ~datomic~, and your
  connection to the Database cluster is bound to ~db-conn~, you can
  simply transact your schema like this:

#+BEGIN_SRC clojure
  (datomic/transact db-conn {:tx-data datomic-schema})
#+END_SRC

  Several other plugins are available and you can also write your
  own. The following sections detail not only how to model your domain
  but also these options in further detail.

* Hodur Plugins

  + [[https://github.com/luchiniatwork/hodur-graphviz-schema][hodur-graphviz-schema]]: generates beautiful GraphViz diagrams of
    your domain
  + [[https://github.com/luchiniatwork/hodur-datomic-schema][hodur-datomic-schema]]: generates Datomic Cloud-compatible schemas
  + [[https://github.com/luchiniatwork/hodur-lacinia-schema][hodur-lacinia-schema]]: generates Lacinia (GraphQL) schemas
  + [[https://github.com/luchiniatwork/hodur-lacinia-datomic-adapter][hodur-lacinia-datomic-adapter]]: experimental utilities for bridging
    GraphQL queries and mutations into Datomic

* Model Definition

** Entities, fields and parameters

   In Hodur *Entites* are the highest level represenation of a
   model. An *entity* has any number of *fields* that qualify such
   entity.

   For instance, an ~employee~ entity may have an ~empployee-number~,
   a ~name~ and a ~salary~ as three distinct fields. An ~entity~ can have
   as many fields as you need.

   *Fields* can have any number of *parameters*. *Parameters* qualify
   the field. For instance, a hypothetical ~height~ field could have a
   parameter specifying which ~unit~ to use when interpreting this
   *field* (~CENTIMETERS~ or ~FEET~ for instance).

** Basic structure

   Hodur can be initialized by either a series of EDN files (using
   function ~init-path~) or vectors (using function ~init-schema~).

   A domain model is a vector of tuples of symbols and
   sub-vectors. The symbols represent entity names and the sub-vectors
   represent fields.

   An ~Employee~ entity with ~name~ and ~salary~ as fields could be defined as:

#+BEGIN_SRC clojure
  [Employee
   [name
    salary]]
#+END_SRC

   With this setup we are not specifying what ~name~ and ~salary~
   are. It might be a good idea to do something like this:

#+BEGIN_SRC clojure
  [Employee
   [^String name
    ^Float  salary]]
#+END_SRC

   Types are defined using a meta paylaod to the symbol that
   represents the field or the parameter. You can read more about
   scalar types below.

   Types can also be represented by the more explicit meta object:

#+BEGIN_SRC clojure
  [Employee
   [^{:type String} name
    ^{:type Float}  salary]]
#+END_SRC

   Entities are also considered types therefore, if an ~Employee~ has
   a ~supervisor~ who's also an ~Employee~ you might write:

#+BEGIN_SRC clojure
  [Employee
   [^String   name
    ^Float    salary
    ^Employee supervisor]]
#+END_SRC

   You could want a ~height~ field that can return the employee's
   height in a particular unit:

#+BEGIN_SRC clojure
  [Employee
   [^String   name
    ^Float    salary
    ^Employee supervisor
    ^Integer  height [^Unit unit]]

   ^{:enum true}
   Unit
   [CENTIMETERS FEET]]
#+END_SRC

   There's quite a bit going on here that you can explore in detail in
   the sections below. But here's a summary. First we've added the
   field ~height~ to the ~Employee~ entity. It returns an ~Integer~
   and it also expects a parameter called ~unit~ of the type ~Unit~.

   We've defined ~Unit~ separately as an enum (you can see more
   details in the sections below). ~Unit~ can be either ~CENTIMETER~
   or ~FEET~.

** Scalar types

   Hodur has five primitive scalar types that can be composed with
   your own entities to design your model. Four of them are quite
   self-explanatory: ~String~, ~Float~, ~Integer~ and ~Boolean~.

   The last two are highly opinionated and are ~DateTime~ and ~ID~.

   Hodur's plugins must have reasonable defaults to represent each one
   of these scalar types. Plugins may also expose finer grained
   controls to manage type precision (for instance 32bit integers vs
   64bit integers).

** Cardinalities

   One employee may have a series of reportees. This kind of
   cardinality is defined with the ~:cardinality~ meta marker:

#+BEGIN_SRC clojure
  [Employee
   [^{:type String}       name
    ^{:type Float}        salary
    ^{:type Employee
      :cardinality [0 n]} reportees]]
#+END_SRC

   In this example we are telling Hodur that ~reportees~ can be
   anywhere from ~0~ employees to ~n~ employees.

   You can be as specific as you want. A cardinality of ~[4]~ means
   exactly ~4~ entries; ~[3 5]~ means ~3~ to ~5~. If ~:cardinality~ is
   unspecified, it's assumed as ~[1]~.

** Optional fields and parameters

   Fields and parameters are required by default. In other words,
   plugins must implement mechanisms to avoid ~null~ problems if a
   field or parameter is mandatory.

   If you want to make a field optional, use the ~:optional~ meta
   marker on the field:

#+BEGIN_SRC clojure
  [Employee
   [^{:type String}    first-name
    ^{:type String
      :optional true}  middle-name
    ^{:type String}    last-name]]
#+END_SRC

   If you want to make a parameter optional, use the ~:optional~ meta
   marker on the parameter:

#+BEGIN_SRC clojure
  [QueryRoot
   [employees [^{:type String
                 :optional true} search-term]]]
#+END_SRC

** Special entity markers

*** Interfaces and Implementations

    Entities can be marked as ~:interface~ which can be used by
    plugins that explore such a concept. Entities that implement an
    interface use the ~:implements~ marker to indicate which
    interface(s) they implement:

#+BEGIN_SRC clojure
  [^{:interface true}
   Pet
   [^String name]

   ^{:implements Pet}
   Dog
   [^String bark]

   ^{:implements Pet}
   Cat
   [^String mewow]]
#+END_SRC

    The ~:implements~ marker also accepts a vector with a series of
    interfaces that the entity implements.

*** Enums

    Enums are special kind of entities. They can assume one of the
    values defined as fields. Enum fields do not support parameters.

    Enums are marked with ~:enum~:

#+BEGIN_SRC clojure
  [Employee
   [^String   name
    ^Float    salary
    ^Employee supervisor
    ^Integer  height [^Unit unit]]

   ^{:enum true}
   Unit
   [CENTIMETERS FEET]]
#+END_SRC

*** Unions

** Documentation and deprecation

** Tagging

*** Recursive tagging

*** Default tagging

** Naming conventions
* Meta API
* Authoring Plugins
* Bugs

If you find a bug, submit a [[https://github.com/luchiniatwork/hodur-engine/issues][GitHub issue]].

* Help!

This project is looking for team members who can help this project
succeed! If you are interested in becoming a team member please open
an issue.

* License

Copyright Â© 2018 Tiago Luchini

Distributed under the MIT License.
